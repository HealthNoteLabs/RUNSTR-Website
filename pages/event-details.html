<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event Details - RUNSTR</title>

    <!-- Nostr Login -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nostr-login@latest/dist/unpkg.css">
    <script type="module" src="https://cdn.jsdelivr.net/npm/nostr-login@latest/dist/unpkg.js"></script>

    <!-- Nostr Tools for Nostr operations -->
    <script src="https://unpkg.com/nostr-tools@2.7.2/lib/nostr.bundle.js"></script>

    <!-- QR Code Library for Lightning invoices -->
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --black: #0a0a0a;
            --dark-gray: #1a1a1a;
            --medium-gray: #2a2a2a;
            --light-gray: #888;
            --white: #ffffff;
            --accent: #f0f0f0;
            --orange: #F5A356;
            --green: #44ff44;
            --yellow: #ffcc00;
            --red: #ff4444;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--black);
            color: var(--white);
            line-height: 1.6;
        }

        /* Navigation Header */
        .nav-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--medium-gray);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-logo {
            font-size: 1.5rem;
            font-weight: 900;
            color: var(--white);
            text-decoration: none;
            letter-spacing: -1px;
        }

        .back-btn {
            padding: 0.5rem 1rem;
            background: transparent;
            color: var(--light-gray);
            text-decoration: none;
            border: 1px solid var(--medium-gray);
            font-size: 0.9rem;
            margin-right: 1rem;
        }

        .back-btn:hover {
            color: var(--white);
            border-color: var(--light-gray);
        }

        /* Main Content */
        .main-content {
            max-width: 1400px;
            margin: 6rem auto 2rem;
            padding: 2rem;
        }

        /* Event Header */
        .event-header {
            background: var(--dark-gray);
            border: 1px solid var(--medium-gray);
            padding: 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
        }

        .event-title-row {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
        }

        .event-title {
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 0.5rem;
        }

        .status-badge {
            padding: 0.5rem 1rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            display: inline-block;
        }

        .status-upcoming {
            background: rgba(255, 204, 0, 0.2);
            color: var(--yellow);
        }

        .status-active {
            background: rgba(68, 255, 68, 0.2);
            color: var(--green);
        }

        .status-completed {
            background: rgba(136, 136, 136, 0.2);
            color: var(--light-gray);
        }

        .event-meta {
            color: var(--light-gray);
            margin-bottom: 1rem;
        }

        .event-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        /* Grid Layout */
        .content-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
        }

        /* Section */
        .section {
            background: var(--dark-gray);
            border: 1px solid var(--medium-gray);
            padding: 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 900;
        }

        /* Leaderboard */
        .leaderboard {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .leaderboard-item {
            background: var(--medium-gray);
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--dark-gray);
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: all 0.3s;
        }

        .leaderboard-item:hover {
            border-color: var(--orange);
        }

        .rank {
            font-size: 1.5rem;
            font-weight: 900;
            color: var(--orange);
            min-width: 50px;
            text-align: center;
        }

        .rank-1 { color: #FFD700; } /* Gold */
        .rank-2 { color: #C0C0C0; } /* Silver */
        .rank-3 { color: #CD7F32; } /* Bronze */

        .participant-info {
            flex: 1;
        }

        .participant-name {
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .participant-pubkey {
            color: var(--light-gray);
            font-size: 0.85rem;
            font-family: monospace;
        }

        .score {
            text-align: right;
        }

        .score-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--white);
        }

        .score-label {
            color: var(--light-gray);
            font-size: 0.85rem;
        }

        /* Participant List */
        .participant-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }

        .participant-card {
            background: var(--medium-gray);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--dark-gray);
            text-align: center;
        }

        .participant-card .participant-name {
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .participant-card .participant-pubkey {
            color: var(--light-gray);
            font-size: 0.75rem;
            font-family: monospace;
        }

        /* Info Grid */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            color: var(--light-gray);
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }

        .info-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--orange);
        }

        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            background: var(--orange);
            color: var(--black);
            text-decoration: none;
            font-weight: 700;
            transition: all 0.3s;
            border: 2px solid var(--orange);
            font-size: 0.9rem;
            cursor: pointer;
        }

        .btn:hover {
            background: transparent;
            color: var(--orange);
        }

        .btn-secondary {
            background: transparent;
            color: var(--light-gray);
            border-color: var(--medium-gray);
        }

        .btn-secondary:hover {
            color: var(--white);
            border-color: var(--light-gray);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 2rem;
            color: var(--light-gray);
        }

        .spinner {
            border: 3px solid var(--medium-gray);
            border-top: 3px solid var(--orange);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--light-gray);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        @media (max-width: 968px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Race Replay Styles */
        .replay-viewer {
            padding: 1rem;
        }

        .race-track {
            position: relative;
            width: 100%;
            height: 150px;
            background: var(--medium-gray);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 1.5rem;
            border: 1px solid var(--dark-gray);
        }

        .track-line {
            position: absolute;
            top: 50%;
            left: 5%;
            width: 90%;
            height: 3px;
            background: linear-gradient(90deg, var(--orange) 0%, var(--light-gray) 50%, var(--orange) 100%);
            transform: translateY(-50%);
        }

        .track-markers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .distance-marker {
            position: absolute;
            text-align: center;
            color: var(--light-gray);
            font-size: 0.7rem;
            font-weight: 600;
        }

        .distance-marker-label {
            position: absolute;
            bottom: 20px;
            transform: translateX(-50%);
        }

        .distance-marker-line {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 30px;
            background: var(--dark-gray);
        }

        .runner-avatars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .runner-avatar {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: left 0.3s linear;
            z-index: 10;
        }

        .runner-dot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--orange);
            border: 3px solid var(--white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 900;
            color: var(--black);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .runner-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--white);
            background: var(--black);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .runner-avatar:hover .runner-label {
            opacity: 1;
        }

        .playback-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            justify-content: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 0.75rem 1.5rem;
            background: var(--medium-gray);
            color: var(--white);
            border: 2px solid var(--medium-gray);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }

        .control-btn:hover {
            background: var(--orange);
            border-color: var(--orange);
            color: var(--black);
        }

        .control-btn.active {
            background: var(--orange);
            border-color: var(--orange);
            color: var(--black);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .race-time {
            text-align: center;
            font-size: 2rem;
            font-weight: 900;
            color: var(--orange);
            margin-bottom: 1.5rem;
            font-family: monospace;
        }

        .live-standings {
            background: var(--medium-gray);
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--dark-gray);
        }

        .live-standings h3 {
            margin-bottom: 1rem;
            font-weight: 700;
            font-size: 1.1rem;
        }

        .standing-item {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem;
            border-bottom: 1px solid var(--dark-gray);
            align-items: center;
        }

        .standing-item:last-child {
            border-bottom: none;
        }

        .standing-position {
            font-weight: 900;
            color: var(--orange);
            min-width: 30px;
        }

        .standing-position.pos-1 { color: #FFD700; }
        .standing-position.pos-2 { color: #C0C0C0; }
        .standing-position.pos-3 { color: #CD7F32; }

        .standing-name {
            flex: 1;
            margin-left: 1rem;
        }

        .standing-stats {
            text-align: right;
            color: var(--light-gray);
            font-size: 0.9rem;
        }

        .replay-empty {
            text-align: center;
            padding: 2rem;
            color: var(--light-gray);
        }

        @media (max-width: 768px) {
            .race-track {
                height: 120px;
            }

            .runner-dot {
                width: 28px;
                height: 28px;
                font-size: 0.7rem;
            }

            .playback-controls {
                gap: 0.5rem;
            }

            .control-btn {
                padding: 0.5rem 1rem;
                font-size: 0.8rem;
            }

            .race-time {
                font-size: 1.5rem;
            }
        }

        /* Anti-Cheat Styles */
        #anti-cheat-prompt {
            padding: 1rem;
            text-align: center;
        }

        .payment-modal-overlay {
            background: var(--medium-gray);
            padding: 2rem;
            border-radius: 8px;
            border: 1px solid var(--dark-gray);
        }

        .payment-modal-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .payment-modal-header h3 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .qr-code-container {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 0 auto 1.5rem;
            max-width: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .invoice-string {
            background: var(--dark-gray);
            padding: 1rem;
            margin-bottom: 1.5rem;
            word-break: break-all;
            font-family: monospace;
            font-size: 0.75rem;
            border-radius: 4px;
            max-height: 100px;
            overflow-y: auto;
            border: 1px solid var(--medium-gray);
        }

        .copy-invoice-btn {
            margin-bottom: 1rem;
        }

        .payment-status {
            text-align: center;
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(245, 163, 86, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(245, 163, 86, 0.3);
        }

        .payment-status-text {
            color: var(--orange);
            font-weight: 600;
            font-size: 0.95rem;
        }

        .anti-cheat-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .anti-cheat-item {
            background: var(--medium-gray);
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid;
            transition: all 0.3s;
        }

        .anti-cheat-item:hover {
            transform: translateX(5px);
        }

        .anti-cheat-item.risk-low {
            border-left-color: #44ff44;
        }

        .anti-cheat-item.risk-medium {
            border-left-color: #ffcc00;
        }

        .anti-cheat-item.risk-high {
            border-left-color: #ff4444;
        }

        .anti-cheat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .anti-cheat-name {
            font-weight: 700;
            font-size: 1.1rem;
        }

        .anti-cheat-score {
            text-align: right;
        }

        .anti-cheat-score-value {
            font-size: 1.8rem;
            font-weight: 900;
            line-height: 1;
        }

        .anti-cheat-score-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 0.25rem;
            opacity: 0.8;
        }

        .risk-low .anti-cheat-score-value {
            color: #44ff44;
        }

        .risk-medium .anti-cheat-score-value {
            color: #ffcc00;
        }

        .risk-high .anti-cheat-score-value {
            color: #ff4444;
        }

        .anti-cheat-flags {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--dark-gray);
        }

        .anti-cheat-flags-header {
            font-size: 0.85rem;
            color: var(--light-gray);
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .anti-cheat-flag {
            font-size: 0.85rem;
            color: var(--accent);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }

        .anti-cheat-flag::before {
            content: '‚Ä¢';
            color: var(--orange);
            font-weight: 700;
        }

        .anti-cheat-no-flags {
            color: var(--light-gray);
            font-size: 0.85rem;
            font-style: italic;
        }

        .anti-cheat-disclaimer {
            margin-top: 2rem;
            padding: 1rem;
            background: var(--medium-gray);
            border-radius: 8px;
            border: 1px solid var(--dark-gray);
        }

        .anti-cheat-disclaimer p {
            font-size: 0.85rem;
            color: var(--light-gray);
            line-height: 1.5;
            margin: 0;
        }

        .anti-cheat-disclaimer strong {
            color: var(--white);
        }

        .pulse-animation {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }

        @media (max-width: 768px) {
            .payment-modal-overlay {
                padding: 1.5rem;
            }

            .qr-code-container {
                max-width: 250px;
                padding: 1rem;
            }

            .anti-cheat-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
            }

            .anti-cheat-score {
                width: 100%;
                text-align: left;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Header -->
    <header class="nav-header">
        <div style="display: flex; align-items: center;">
            <a href="team-management.html" class="back-btn" id="back-link">‚Üê Back to Team</a>
            <a href="../index.html" class="nav-logo">RUNSTR</a>
        </div>
        <div class="nav-actions">
            <nostr-login></nostr-login>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Loading State -->
        <div id="loading-section" class="loading">
            <div class="spinner"></div>
            <p style="margin-top: 1rem;">Loading event...</p>
        </div>

        <!-- Event Content -->
        <div id="event-content" style="display: none;">
            <!-- Event Header -->
            <div class="event-header">
                <div class="event-title-row">
                    <div>
                        <h1 class="event-title" id="event-title">Event Name</h1>
                        <div class="event-meta" id="event-meta">Event ‚Ä¢ Running ‚Ä¢ Total Distance</div>
                    </div>
                    <span class="status-badge" id="status-badge">Upcoming</span>
                </div>
                <p id="event-description" style="color: var(--light-gray); margin-bottom: 1.5rem;">Event description</p>

                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">Start Date</div>
                        <div class="info-value" id="start-date">-</div>
                    </div>
                    <div class="info-item" id="end-date-item">
                        <div class="info-label">End Date</div>
                        <div class="info-value" id="end-date">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Entry Fee</div>
                        <div class="info-value" id="entry-fee">Free</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Participants</div>
                        <div class="info-value" id="participant-count">0</div>
                    </div>
                </div>

                <div class="event-actions">
                    <button class="btn" id="join-btn" style="display: none;" onclick="joinEvent()">Join Event</button>
                    <button class="btn" id="pending-btn" style="display: none;" disabled>Request Pending</button>
                    <button class="btn btn-secondary" id="refresh-btn" onclick="refreshLeaderboard()">Refresh Leaderboard</button>
                </div>
            </div>

            <!-- Race Replay Section -->
            <div id="race-replay-section" class="section" style="display: none;">
                <div class="section-header">
                    <h2 class="section-title">Race Replay</h2>
                    <span style="color: var(--light-gray); font-size: 0.9rem;">Watch the race unfold</span>
                </div>

                <div id="replay-viewer"></div>
            </div>

            <!-- Anti-Cheat Verification Section (Captain Only) -->
            <div id="anti-cheat-section" class="section" style="display: none;">
                <div class="section-header">
                    <h2 class="section-title">Anti-Cheat Verification</h2>
                    <span style="color: var(--orange); font-size: 0.9rem;">500 sats</span>
                </div>

                <div id="anti-cheat-content">
                    <!-- Prompt to run analysis -->
                    <div id="anti-cheat-prompt">
                        <p style="color: var(--light-gray); margin-bottom: 1.5rem; line-height: 1.6;">
                            Run algorithmic analysis on participant workouts to detect suspicious patterns including:
                            impossible pace changes, GPS data quality issues, math inconsistencies, and more.
                        </p>
                        <button class="btn" onclick="startAntiCheatAnalysis()">
                            üîç Run Anti-Cheat Analysis (500 sats)
                        </button>
                    </div>

                    <!-- Payment Modal -->
                    <div id="payment-modal" style="display: none;"></div>

                    <!-- Results Display -->
                    <div id="anti-cheat-results" style="display: none;"></div>
                </div>
            </div>

            <!-- Content Grid -->
            <div class="content-grid">
                <!-- Leaderboard -->
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">Leaderboard</h2>
                    </div>

                    <div id="leaderboard-loading" class="loading">
                        <div class="spinner"></div>
                        <p style="margin-top: 1rem;">Calculating leaderboard...</p>
                    </div>

                    <div id="leaderboard" class="leaderboard" style="display: none;"></div>

                    <div id="leaderboard-empty" class="empty-state" style="display: none;">
                        <div class="empty-state-icon">üèÜ</div>
                        <p>No workouts yet</p>
                        <p style="font-size: 0.9rem; margin-top: 0.5rem;">Participants will appear here once they post workouts</p>
                    </div>
                </div>

                <!-- Participants -->
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">Participants</h2>
                    </div>

                    <div id="participant-loading" class="loading">
                        <div class="spinner"></div>
                        <p style="margin-top: 1rem;">Loading participants...</p>
                    </div>

                    <div id="participant-list" class="participant-list" style="display: none;"></div>

                    <div id="participant-empty" class="empty-state" style="display: none;">
                        <div class="empty-state-icon">üë•</div>
                        <p>No participants yet</p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        let pool;
        let currentUser = null;
        let currentEvent = null;
        let participants = [];
        let eventId = null;
        let teamId = null;
        let captainPubkey = null;
        const RELAYS = ['wss://relay.damus.io', 'wss://nos.lol', 'wss://relay.nostr.band'];

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        eventId = urlParams.get('eventId');
        teamId = urlParams.get('teamId');
        captainPubkey = urlParams.get('captain');

        // Update back link
        if (teamId && captainPubkey) {
            document.getElementById('back-link').href = `team-management.html?teamId=${encodeURIComponent(teamId)}&captain=${encodeURIComponent(captainPubkey)}`;
        }

        // Competition type labels
        const competitionTypeLabels = {
            'total_distance': 'Total Distance',
            'single_distance': 'Single Workout Distance',
            'fastest_pace': 'Fastest Pace',
            'most_workouts': 'Most Workouts',
            'total_calories': 'Total Calories',
            'elevation_gain': 'Elevation Gain',
            'longest_duration': 'Longest Duration'
        };

        // Initialize nostr-tools SimplePool
        function initializeNostr() {
            try {
                pool = new NostrTools.SimplePool();
                console.log('‚úÖ Nostr pool initialized');
                return pool;
            } catch (error) {
                console.error('‚ùå Failed to initialize Nostr pool:', error);
                throw error;
            }
        }

        // Listen for nostr-login events
        document.addEventListener('nlAuth', async (e) => {
            console.log('üîê User logged in:', e.detail);
            currentUser = e.detail;

            if (!pool) {
                initializeNostr();
            }

            // Reload event to update join button and show captain features
            await loadEvent();

            // Show anti-cheat section if captain
            if (currentUser.pubkey === captainPubkey) {
                document.getElementById('anti-cheat-section').style.display = 'block';
                console.log('üëë Captain logged in - anti-cheat verification available');
            }
        });

        // Load event data
        async function loadEvent() {
            try {
                console.log('üìã Loading event:', eventId);

                if (!eventId) {
                    alert('No event ID provided');
                    window.location.href = 'dashboard.html';
                    return;
                }

                // Query event data
                const filter = {
                    kinds: [30100, 30101],
                    '#d': [eventId]
                };

                const events = await pool.querySync(RELAYS, filter);
                const eventArray = events || [];

                if (eventArray.length === 0) {
                    alert('Event not found');
                    window.location.href = 'dashboard.html';
                    return;
                }

                currentEvent = eventArray[0];

                // Extract event details
                const nameTag = currentEvent.tags.find(t => t[0] === 'name');
                const name = nameTag ? nameTag[1] : 'Unnamed Event';

                const activityTag = currentEvent.tags.find(t => t[0] === 'activity_type');
                const activityType = activityTag ? activityTag[1] : 'unknown';

                const competitionTag = currentEvent.tags.find(t => t[0] === 'competition_type');
                const competitionType = competitionTag ? competitionTag[1] : 'unknown';

                const statusTag = currentEvent.tags.find(t => t[0] === 'status');
                const status = statusTag ? statusTag[1] : 'unknown';

                const startTag = currentEvent.tags.find(t => t[0] === 'start');
                const startDate = startTag ? startTag[1] : null;

                const endTag = currentEvent.tags.find(t => t[0] === 'end');
                const endDate = endTag ? endTag[1] : null;

                const entryFeeTag = currentEvent.tags.find(t => t[0] === 'entry_fee');
                const entryFee = entryFeeTag ? parseInt(entryFeeTag[1]) : 0;

                const maxParticipantsTag = currentEvent.tags.find(t => t[0] === 'max_participants');
                const maxParticipants = maxParticipantsTag ? parseInt(maxParticipantsTag[1]) : null;

                const description = currentEvent.content || 'No description';

                const isLeague = currentEvent.kind === 30100;
                const eventType = isLeague ? 'League' : 'Event';

                // Update UI
                document.getElementById('event-title').textContent = name;
                document.getElementById('event-meta').textContent = `${eventType} ‚Ä¢ ${activityType.charAt(0).toUpperCase() + activityType.slice(1)} ‚Ä¢ ${competitionTypeLabels[competitionType] || competitionType}`;
                document.getElementById('event-description').textContent = description;
                document.getElementById('start-date').textContent = startDate ? new Date(startDate).toLocaleDateString() : '-';

                if (isLeague) {
                    document.getElementById('end-date-item').style.display = 'none';
                } else {
                    document.getElementById('end-date').textContent = endDate ? new Date(endDate).toLocaleDateString() : '-';
                }

                document.getElementById('entry-fee').textContent = entryFee > 0 ? `${entryFee} sats` : 'Free';

                // Status badge
                const statusBadge = document.getElementById('status-badge');
                statusBadge.textContent = status;
                statusBadge.className = 'status-badge status-' + status;

                // Show content
                document.getElementById('loading-section').style.display = 'none';
                document.getElementById('event-content').style.display = 'block';

                // Show anti-cheat section if current user is the captain
                if (currentUser && currentUser.pubkey === captainPubkey) {
                    document.getElementById('anti-cheat-section').style.display = 'block';
                    console.log('üëë Captain detected - anti-cheat verification available');
                }

                // Load participants and leaderboard
                await Promise.all([
                    loadParticipants(),
                    loadLeaderboard()
                ]);

                // Update join button
                updateJoinButton();

            } catch (error) {
                console.error('‚ùå Failed to load event:', error);
                alert('Failed to load event');
            }
        }

        // Load participants
        async function loadParticipants() {
            const participantLoading = document.getElementById('participant-loading');
            const participantList = document.getElementById('participant-list');
            const participantEmpty = document.getElementById('participant-empty');

            try {
                participantLoading.style.display = 'block';
                participantList.style.display = 'none';
                participantEmpty.style.display = 'none';

                // Query participant list
                const filter = {
                    kinds: [30000],
                    '#d': [eventId]
                };

                const events = await pool.querySync(RELAYS, filter);
                const listEvents = events || [];

                participants = [];

                if (listEvents.length > 0) {
                    const participantListEvent = listEvents[0];
                    const participantTags = participantListEvent.tags.filter(t => t[0] === 'p');
                    participants = participantTags.map(t => t[1]);
                }

                console.log(`‚úÖ Found ${participants.length} participants`);

                participantLoading.style.display = 'none';

                // Update participant count
                document.getElementById('participant-count').textContent = participants.length;

                if (participants.length === 0) {
                    participantEmpty.style.display = 'block';
                    return;
                }

                participantList.style.display = 'grid';
                participantList.innerHTML = participants
                    .map(pubkey => renderParticipantCard(pubkey))
                    .join('');

            } catch (error) {
                console.error('‚ùå Failed to load participants:', error);
                participantLoading.style.display = 'none';
                participantEmpty.style.display = 'block';
            }
        }

        // Render participant card
        function renderParticipantCard(pubkey) {
            const shortPubkey = pubkey.substring(0, 8) + '...' + pubkey.substring(pubkey.length - 8);

            return `
                <div class="participant-card">
                    <div class="participant-name">Athlete</div>
                    <div class="participant-pubkey">${shortPubkey}</div>
                </div>
            `;
        }

        // Load leaderboard
        async function loadLeaderboard() {
            const leaderboardLoading = document.getElementById('leaderboard-loading');
            const leaderboard = document.getElementById('leaderboard');
            const leaderboardEmpty = document.getElementById('leaderboard-empty');

            try {
                leaderboardLoading.style.display = 'block';
                leaderboard.style.display = 'none';
                leaderboardEmpty.style.display = 'none';

                if (participants.length === 0) {
                    leaderboardLoading.style.display = 'none';
                    leaderboardEmpty.style.display = 'block';
                    return;
                }

                // Get event date range
                const startTag = currentEvent.tags.find(t => t[0] === 'start');
                const startDate = startTag ? new Date(startTag[1]).getTime() / 1000 : 0;

                const endTag = currentEvent.tags.find(t => t[0] === 'end');
                const endDate = endTag ? new Date(endTag[1]).getTime() / 1000 : Math.floor(Date.now() / 1000);

                const activityTag = currentEvent.tags.find(t => t[0] === 'activity_type');
                const activityType = activityTag ? activityTag[1] : null;

                // Query workouts for all participants
                const filter = {
                    kinds: [1301],
                    authors: participants,
                    since: Math.floor(startDate),
                    until: Math.floor(endDate)
                };

                const events = await pool.querySync(RELAYS, filter);
                const workouts = (events || []).filter(workout => {
                    const typeTag = workout.tags.find(t => t[0] === 'type');
                    return typeTag && typeTag[1] === activityType;
                });

                console.log(`‚úÖ Found ${workouts.length} workouts for leaderboard`);

                // Build race replay from workouts with split data
                const raceTimeline = buildRaceTimeline(workouts);

                if (raceTimeline.length > 0) {
                    console.log(`üé¨ Found ${raceTimeline.length} participants with split data for race replay`);

                    // Show race replay section
                    const replaySection = document.getElementById('race-replay-section');
                    const replayViewer = document.getElementById('replay-viewer');

                    if (replaySection && replayViewer) {
                        // Determine event distance from competition or use max distance from participants
                        const distanceTag = currentEvent.tags.find(t => t[0] === 'distance');
                        const eventDistance = distanceTag ? parseFloat(distanceTag[1]) :
                                            Math.max(...raceTimeline.map(p => p.finalDistance));

                        // Render race replay UI
                        replayViewer.innerHTML = renderRaceReplay(raceTimeline, eventDistance);
                        replaySection.style.display = 'block';

                        // Initialize replay after DOM is ready
                        setTimeout(() => {
                            initRaceReplay(raceTimeline, eventDistance);
                        }, 100);
                    }
                } else {
                    console.log('‚ÑπÔ∏è No participants have split data - race replay unavailable');
                }

                // Calculate leaderboard
                const competitionTag = currentEvent.tags.find(t => t[0] === 'competition_type');
                const competitionType = competitionTag ? competitionTag[1] : 'total_distance';

                const rankings = calculateLeaderboard(workouts, competitionType);

                leaderboardLoading.style.display = 'none';

                if (rankings.length === 0) {
                    leaderboardEmpty.style.display = 'block';
                    return;
                }

                leaderboard.style.display = 'flex';
                leaderboard.innerHTML = rankings
                    .map((ranking, index) => renderLeaderboardItem(ranking, index + 1, competitionType))
                    .join('');

            } catch (error) {
                console.error('‚ùå Failed to load leaderboard:', error);
                leaderboardLoading.style.display = 'none';
                leaderboardEmpty.style.display = 'block';
            }
        }

        // Calculate leaderboard based on competition type
        function calculateLeaderboard(workouts, competitionType) {
            // Group workouts by participant
            const participantWorkouts = {};
            workouts.forEach(workout => {
                if (!participantWorkouts[workout.pubkey]) {
                    participantWorkouts[workout.pubkey] = [];
                }
                participantWorkouts[workout.pubkey].push(workout);
            });

            // Calculate scores for each participant
            const scores = Object.entries(participantWorkouts).map(([pubkey, userWorkouts]) => {
                let score = 0;
                let unit = '';

                switch (competitionType) {
                    case 'total_distance':
                        userWorkouts.forEach(w => {
                            const distanceTag = w.tags.find(t => t[0] === 'distance');
                            if (distanceTag) {
                                score += parseFloat(distanceTag[1]) || 0;
                            }
                        });
                        unit = 'km';
                        break;

                    case 'single_distance':
                        userWorkouts.forEach(w => {
                            const distanceTag = w.tags.find(t => t[0] === 'distance');
                            if (distanceTag) {
                                const distance = parseFloat(distanceTag[1]) || 0;
                                score = Math.max(score, distance);
                            }
                        });
                        unit = 'km';
                        break;

                    case 'most_workouts':
                        score = userWorkouts.length;
                        unit = 'workouts';
                        break;

                    case 'total_calories':
                        userWorkouts.forEach(w => {
                            try {
                                if (w.content) {
                                    const match = w.content.match(/(\d+)\s*calories/i);
                                    if (match) score += parseInt(match[1]);
                                }
                            } catch (e) {}
                        });
                        unit = 'cal';
                        break;

                    case 'elevation_gain':
                        userWorkouts.forEach(w => {
                            try {
                                if (w.content) {
                                    const match = w.content.match(/(\d+)\s*elevation/i);
                                    if (match) score += parseInt(match[1]);
                                }
                            } catch (e) {}
                        });
                        unit = 'm';
                        break;

                    case 'longest_duration':
                        userWorkouts.forEach(w => {
                            const durationTag = w.tags.find(t => t[0] === 'duration');
                            if (durationTag) {
                                const duration = parseDuration(durationTag[1]);
                                score = Math.max(score, duration);
                            }
                        });
                        unit = 'min';
                        score = Math.floor(score / 60); // Convert to minutes
                        break;

                    case 'fastest_pace':
                        let totalDistance = 0;
                        let totalDuration = 0;
                        userWorkouts.forEach(w => {
                            const distanceTag = w.tags.find(t => t[0] === 'distance');
                            const durationTag = w.tags.find(t => t[0] === 'duration');
                            if (distanceTag && durationTag) {
                                totalDistance += parseFloat(distanceTag[1]) || 0;
                                totalDuration += parseDuration(durationTag[1]);
                            }
                        });
                        if (totalDistance > 0 && totalDuration > 0) {
                            score = (totalDuration / 60) / totalDistance; // min/km
                        }
                        unit = 'min/km';
                        break;
                }

                return {
                    pubkey,
                    score: Math.round(score * 100) / 100,
                    unit,
                    workoutCount: userWorkouts.length
                };
            });

            // Sort by score (descending for most types, ascending for pace)
            if (competitionType === 'fastest_pace') {
                scores.sort((a, b) => a.score - b.score);
            } else {
                scores.sort((a, b) => b.score - a.score);
            }

            return scores;
        }

        // Parse duration string
        function parseDuration(duration) {
            if (!duration) return 0;
            if (typeof duration === 'number') return duration;

            if (duration.includes(':')) {
                const parts = duration.split(':').map(p => parseInt(p) || 0);
                if (parts.length === 3) {
                    return parts[0] * 3600 + parts[1] * 60 + parts[2];
                } else if (parts.length === 2) {
                    return parts[0] * 60 + parts[1];
                }
            }
            return parseInt(duration) || 0;
        }

        // ========== RACE REPLAY FUNCTIONS ==========

        // Parse split data from workout event
        function parseSplitData(workout) {
            const splits = [];

            // Extract split tags: ["split", "1", "00:05:38"]
            const splitTags = workout.tags.filter(t => t[0] === 'split');

            splitTags.forEach(tag => {
                const splitNumber = parseInt(tag[1]);
                const elapsedTime = tag[2]; // Format: "HH:MM:SS" or "MM:SS"
                const elapsedSeconds = parseDuration(elapsedTime);

                splits.push({
                    number: splitNumber,
                    elapsedTime: elapsedTime,
                    elapsedSeconds: elapsedSeconds,
                    distanceKm: splitNumber // Assume 1km per split
                });
            });

            return splits.sort((a, b) => a.number - b.number);
        }

        // Get participant display name (shortened pubkey)
        function getParticipantName(pubkey) {
            return pubkey.substring(0, 6) + '...';
        }

        // Build race timeline from all participants' splits
        function buildRaceTimeline(workouts) {
            const participants = [];

            workouts.forEach(workout => {
                const splits = parseSplitData(workout);

                if (splits.length > 0) {
                    participants.push({
                        pubkey: workout.pubkey,
                        name: getParticipantName(workout.pubkey),
                        splits: splits,
                        totalTime: splits[splits.length - 1].elapsedSeconds,
                        finalDistance: splits[splits.length - 1].distanceKm
                    });
                }
            });

            return participants;
        }

        // Format seconds to MM:SS or HH:MM:SS
        function formatReplayTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);

            if (h > 0) {
                return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // Race replay state
        let replayState = {
            participants: [],
            currentTime: 0,
            maxTime: 0,
            isPlaying: false,
            speed: 1,
            animationId: null,
            eventDistance: 5
        };

        // Render race replay viewer
        function renderRaceReplay(participants, eventDistance) {
            if (participants.length === 0) {
                return '<div class="replay-empty"><p>No split data available for replay</p><p style="font-size: 0.9rem; margin-top: 0.5rem;">Participants need to have splits recorded in their workouts</p></div>';
            }

            return `
                <div class="replay-viewer">
                    <!-- Race Track -->
                    <div class="race-track" id="race-track">
                        <div class="track-line"></div>
                        <div class="track-markers" id="track-markers"></div>
                        <div class="runner-avatars" id="runner-avatars"></div>
                    </div>

                    <!-- Playback Controls -->
                    <div class="playback-controls">
                        <button class="control-btn" id="play-btn" onclick="togglePlayback()">‚ñ∂ Play</button>
                        <button class="control-btn" id="speed-1x" onclick="setSpeed(1)" class="active">1x</button>
                        <button class="control-btn" id="speed-2x" onclick="setSpeed(2)">2x</button>
                        <button class="control-btn" id="speed-4x" onclick="setSpeed(4)">4x</button>
                        <button class="control-btn" onclick="resetReplay()">‚Üª Reset</button>
                    </div>

                    <!-- Race Time -->
                    <div class="race-time" id="race-time">00:00:00</div>

                    <!-- Live Standings -->
                    <div class="live-standings">
                        <h3>Current Standings</h3>
                        <div id="live-standings-list"></div>
                    </div>
                </div>
            `;
        }

        // Initialize race replay
        function initRaceReplay(participants, eventDistance) {
            replayState.participants = participants;
            replayState.maxTime = Math.max(...participants.map(p => p.totalTime));
            replayState.eventDistance = eventDistance || Math.max(...participants.map(p => p.finalDistance));
            replayState.currentTime = 0;
            replayState.isPlaying = false;
            replayState.speed = 1;

            console.log(`üé¨ Race replay initialized: ${participants.length} participants, ${replayState.eventDistance}km, max time ${replayState.maxTime}s`);

            // Render distance markers
            renderDistanceMarkers();

            // Render runner avatars
            renderRunnerAvatars();

            // Update initial positions
            updateRaceReplay();
        }

        // Render distance markers on track
        function renderDistanceMarkers() {
            const markersContainer = document.getElementById('track-markers');
            if (!markersContainer) return;

            const distance = replayState.eventDistance;
            const markerInterval = distance <= 5 ? 1 : Math.ceil(distance / 5); // Show ~5 markers max

            let html = '';
            for (let i = 0; i <= distance; i += markerInterval) {
                const position = 5 + (i / distance) * 90; // 5% margin on each side
                html += `
                    <div class="distance-marker" style="left: ${position}%;">
                        <div class="distance-marker-line"></div>
                        <div class="distance-marker-label">${i}km</div>
                    </div>
                `;
            }

            // Always add finish marker
            if (distance % markerInterval !== 0) {
                html += `
                    <div class="distance-marker" style="left: 95%;">
                        <div class="distance-marker-line"></div>
                        <div class="distance-marker-label">üèÅ ${distance}km</div>
                    </div>
                `;
            }

            markersContainer.innerHTML = html;
        }

        // Render runner avatars
        function renderRunnerAvatars() {
            const container = document.getElementById('runner-avatars');
            if (!container) return;

            const colors = ['#F5A356', '#6496ff', '#44ff44', '#ffcc00', '#ff4444', '#9d4edd', '#06ffa5', '#ff006e'];

            let html = '';
            replayState.participants.forEach((participant, index) => {
                const color = colors[index % colors.length];
                const rank = index + 1;

                html += `
                    <div class="runner-avatar" id="runner-${index}" style="left: 5%;">
                        <div class="runner-dot" style="background: ${color}; border-color: ${color};">
                            ${rank}
                        </div>
                        <div class="runner-label">${participant.name}</div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Calculate runner position at given time
        function getRunnerPosition(participant, currentTime) {
            const splits = participant.splits;

            // Before race starts
            if (currentTime <= 0) return 0;

            // After race finishes
            if (currentTime >= participant.totalTime) {
                return participant.finalDistance;
            }

            // Find which split segment the runner is in
            for (let i = 0; i < splits.length; i++) {
                const split = splits[i];
                const prevSplit = i > 0 ? splits[i - 1] : { elapsedSeconds: 0, distanceKm: 0 };

                if (currentTime <= split.elapsedSeconds) {
                    // Interpolate position within this segment
                    const segmentDuration = split.elapsedSeconds - prevSplit.elapsedSeconds;
                    const timeInSegment = currentTime - prevSplit.elapsedSeconds;
                    const segmentProgress = segmentDuration > 0 ? timeInSegment / segmentDuration : 0;

                    const distance = prevSplit.distanceKm +
                                   (split.distanceKm - prevSplit.distanceKm) * segmentProgress;
                    return distance;
                }
            }

            return participant.finalDistance;
        }

        // Update race replay visualization
        function updateRaceReplay() {
            const currentTime = replayState.currentTime;

            // Update runner positions
            replayState.participants.forEach((participant, index) => {
                const distance = getRunnerPosition(participant, currentTime);
                const positionPercent = 5 + (distance / replayState.eventDistance) * 90; // 5% margin + 90% track

                const runnerElement = document.getElementById(`runner-${index}`);
                if (runnerElement) {
                    runnerElement.style.left = `${Math.min(positionPercent, 95)}%`;
                }
            });

            // Update race time display
            const timeElement = document.getElementById('race-time');
            if (timeElement) {
                timeElement.textContent = formatReplayTime(currentTime);
            }

            // Update live standings
            updateLiveStandings(currentTime);
        }

        // Update live standings
        function updateLiveStandings(currentTime) {
            const standings = replayState.participants.map((participant, index) => {
                const distance = getRunnerPosition(participant, currentTime);
                const finished = currentTime >= participant.totalTime;

                return {
                    originalIndex: index,
                    name: participant.name,
                    distance: distance,
                    finished: finished
                };
            }).sort((a, b) => b.distance - a.distance);

            const standingsElement = document.getElementById('live-standings-list');
            if (standingsElement) {
                standingsElement.innerHTML = standings.map((s, rank) => {
                    const position = rank + 1;
                    const posClass = position <= 3 ? `pos-${position}` : '';

                    return `
                        <div class="standing-item">
                            <span class="standing-position ${posClass}">#${position}</span>
                            <span class="standing-name">${s.name}</span>
                            <span class="standing-stats">
                                ${s.distance.toFixed(2)}km ${s.finished ? '‚úì' : ''}
                            </span>
                        </div>
                    `;
                }).join('');
            }
        }

        // Toggle playback
        function togglePlayback() {
            replayState.isPlaying = !replayState.isPlaying;

            const playBtn = document.getElementById('play-btn');
            if (replayState.isPlaying) {
                playBtn.textContent = '‚è∏ Pause';
                playBtn.classList.add('active');
                startReplayAnimation();
            } else {
                playBtn.textContent = '‚ñ∂ Play';
                playBtn.classList.remove('active');
                stopReplayAnimation();
            }
        }

        // Set playback speed
        function setSpeed(speed) {
            replayState.speed = speed;

            // Update button states
            document.getElementById('speed-1x').classList.remove('active');
            document.getElementById('speed-2x').classList.remove('active');
            document.getElementById('speed-4x').classList.remove('active');
            document.getElementById(`speed-${speed}x`).classList.add('active');

            console.log(`‚ö° Playback speed: ${speed}x`);
        }

        // Start replay animation
        function startReplayAnimation() {
            let lastTimestamp = performance.now();

            function animate(timestamp) {
                if (!replayState.isPlaying) return;

                const deltaTime = (timestamp - lastTimestamp) / 1000; // Convert to seconds
                lastTimestamp = timestamp;

                replayState.currentTime += deltaTime * replayState.speed;

                // Check if replay finished
                if (replayState.currentTime >= replayState.maxTime) {
                    replayState.currentTime = replayState.maxTime;
                    replayState.isPlaying = false;

                    const playBtn = document.getElementById('play-btn');
                    if (playBtn) {
                        playBtn.textContent = '‚ñ∂ Replay';
                        playBtn.classList.remove('active');
                    }

                    console.log('üèÅ Race replay finished');
                }

                updateRaceReplay();

                if (replayState.isPlaying) {
                    replayState.animationId = requestAnimationFrame(animate);
                }
            }

            replayState.animationId = requestAnimationFrame(animate);
        }

        // Stop replay animation
        function stopReplayAnimation() {
            if (replayState.animationId) {
                cancelAnimationFrame(replayState.animationId);
                replayState.animationId = null;
            }
        }

        // Reset replay
        function resetReplay() {
            replayState.currentTime = 0;
            replayState.isPlaying = false;
            stopReplayAnimation();

            const playBtn = document.getElementById('play-btn');
            if (playBtn) {
                playBtn.textContent = '‚ñ∂ Play';
                playBtn.classList.remove('active');
            }

            updateRaceReplay();
            console.log('üîÑ Race replay reset');
        }

        // ========== ANTI-CHEAT VERIFICATION SYSTEM ==========

        // RUNSTR NWC wallet for receiving anti-cheat payments
        const RUNSTR_NWC = 'nostr+walletconnect://34fa77fc52edce7f6dd8764d84d9be3ae85003ec367887c5f4fa1f3025e5a415?relay=wss://relay.getalby.com/v1&secret=60547257f5f4f3683e0b2e32e116a8401465d9ecf5ac6e846adcdfc470689c1b&lud16=hustle@getalby.com';

        const ANTI_CHEAT_PRICE_SATS = 500;

        // Anti-cheat state
        let antiCheatState = {
            invoice: null,
            paymentHash: null,
            analyzing: false,
            pollInterval: null
        };

        // Start anti-cheat analysis (triggered by captain)
        async function startAntiCheatAnalysis() {
            // Check if results are cached
            const cached = loadCachedAntiCheatResults(eventId);
            if (cached) {
                const useCache = confirm('Anti-cheat analysis already exists for this event. Show cached results? (Click Cancel to run new analysis for 500 sats)');
                if (useCache) {
                    displayAntiCheatResults(cached);
                    document.getElementById('anti-cheat-prompt').style.display = 'none';
                    document.getElementById('anti-cheat-results').style.display = 'block';
                    return;
                }
            }

            console.log('üîç Starting anti-cheat analysis...');

            // Create Lightning invoice
            await createAntiCheatInvoice();
        }

        // Create Lightning invoice via RUNSTR NWC
        async function createAntiCheatInvoice() {
            try {
                console.log('üí∞ Creating invoice:', ANTI_CHEAT_PRICE_SATS, 'sats');

                // Parse NWC connection string
                const nwcUrl = new URL(RUNSTR_NWC);
                const walletPubkey = nwcUrl.hostname;
                const relayUrl = nwcUrl.searchParams.get('relay');
                const secret = nwcUrl.searchParams.get('secret');

                if (!walletPubkey || !relayUrl || !secret) {
                    throw new Error('Invalid NWC connection string');
                }

                // Create NIP-47 make_invoice request
                const invoiceRequest = {
                    kind: 23194,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [['p', walletPubkey]],
                    content: await encryptNWCRequest({
                        method: 'make_invoice',
                        params: {
                            amount: ANTI_CHEAT_PRICE_SATS * 1000, // Convert to millisats
                            description: `RUNSTR Anti-Cheat Analysis - Event: ${eventId.substring(0, 20)}...`
                        }
                    }, walletPubkey, secret)
                };

                // Note: In a real implementation, you'd sign with a dedicated key
                // For now, we'll use window.nostr if available, or skip signing
                console.log('üì§ Publishing invoice request to NWC relay:', relayUrl);

                // For this MVP, we'll use a simplified approach with WebLN or LNURL
                // Instead of full NWC implementation, let's use LNURL-pay endpoint
                await createInvoiceViaLNURL();

            } catch (error) {
                console.error('‚ùå Failed to create invoice:', error);
                alert('Failed to create payment invoice. Please contact support.');
            }
        }

        // Simplified: Create invoice using LNURL (fallback method)
        async function createInvoiceViaLNURL() {
            try {
                // For MVP: Generate a simple invoice request
                // In production, you'd call your LNURL-pay endpoint

                // Simulated invoice for testing (replace with real LNURL endpoint)
                const mockInvoice = 'lnbc5000n1pjk...' + Math.random().toString(36).substring(7);

                console.log('‚ö° Generated invoice:', mockInvoice);

                antiCheatState.invoice = mockInvoice;
                antiCheatState.paymentHash = 'simulated_' + Date.now();

                // Display payment modal
                displayPaymentModal(mockInvoice);

                // Start polling for payment
                startPaymentPolling();

            } catch (error) {
                console.error('‚ùå Invoice creation failed:', error);
                alert('Payment system error. Please try again.');
            }
        }

        // Encrypt NWC request content
        async function encryptNWCRequest(content, recipientPubkey, sharedSecret) {
            // NIP-47 uses NIP-04 encryption
            // For MVP, return JSON string (in production, implement full encryption)
            return JSON.stringify(content);
        }

        // Display payment modal with QR code and invoice
        function displayPaymentModal(invoice) {
            const paymentModal = document.getElementById('payment-modal');
            const antiCheatPrompt = document.getElementById('anti-cheat-prompt');

            antiCheatPrompt.style.display = 'none';
            paymentModal.style.display = 'block';

            paymentModal.innerHTML = `
                <div class="payment-modal-overlay">
                    <div class="payment-modal-header">
                        <h3>Pay ${ANTI_CHEAT_PRICE_SATS} sats</h3>
                        <p style="color: var(--light-gray);">Scan with Lightning wallet or copy invoice</p>
                    </div>

                    <div class="qr-code-container" id="qr-code-container">
                        <div id="qrcode"></div>
                    </div>

                    <div class="invoice-string" id="invoice-string">
                        ${invoice}
                    </div>

                    <button class="btn copy-invoice-btn" onclick="copyInvoiceToClipboard()">
                        üìã Copy Invoice
                    </button>

                    <div class="payment-status">
                        <p class="payment-status-text pulse-animation">
                            ‚è≥ Waiting for payment...
                        </p>
                    </div>

                    <button class="btn btn-secondary" style="margin-top: 1rem;" onclick="cancelPayment()">
                        Cancel
                    </button>
                </div>
            `;

            // Generate QR code
            setTimeout(() => {
                const qrContainer = document.getElementById('qrcode');
                if (qrContainer && typeof QRCode !== 'undefined') {
                    new QRCode(qrContainer, {
                        text: invoice.toUpperCase(),
                        width: 250,
                        height: 250,
                        colorDark: '#000000',
                        colorLight: '#ffffff',
                        correctLevel: QRCode.CorrectLevel.L
                    });
                }
            }, 100);
        }

        // Copy invoice to clipboard
        function copyInvoiceToClipboard() {
            const invoiceString = document.getElementById('invoice-string');
            if (invoiceString) {
                const invoice = invoiceString.textContent.trim();
                navigator.clipboard.writeText(invoice).then(() => {
                    alert('‚úÖ Invoice copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    alert('Failed to copy. Please select and copy manually.');
                });
            }
        }

        // Cancel payment
        function cancelPayment() {
            if (antiCheatState.pollInterval) {
                clearInterval(antiCheatState.pollInterval);
            }

            document.getElementById('payment-modal').style.display = 'none';
            document.getElementById('anti-cheat-prompt').style.display = 'block';

            antiCheatState.invoice = null;
            antiCheatState.paymentHash = null;
        }

        // Start polling for payment confirmation
        function startPaymentPolling() {
            let attempts = 0;
            const maxAttempts = 60; // 5 minutes (60 √ó 5 seconds)

            antiCheatState.pollInterval = setInterval(async () => {
                attempts++;

                // Check payment status
                const paid = await checkPaymentStatus();

                if (paid) {
                    clearInterval(antiCheatState.pollInterval);
                    console.log('‚úÖ Payment confirmed!');

                    // Hide payment modal
                    document.getElementById('payment-modal').style.display = 'none';

                    // Run anti-cheat analysis
                    await runAntiCheatAnalysis();
                }

                if (attempts >= maxAttempts) {
                    clearInterval(antiCheatState.pollInterval);
                    alert('‚è∞ Payment timeout. Please try again.');
                    cancelPayment();
                }
            }, 5000); // Check every 5 seconds
        }

        // Check payment status (simplified for MVP)
        async function checkPaymentStatus() {
            // For MVP: Simulate payment after 10 seconds for testing
            // In production: Query NWC wallet or LNURL endpoint for payment status

            // Simulate payment detection (remove in production)
            if (antiCheatState.paymentHash && antiCheatState.paymentHash.startsWith('simulated_')) {
                const elapsed = Date.now() - parseInt(antiCheatState.paymentHash.split('_')[1]);
                if (elapsed > 10000) { // Auto-confirm after 10 seconds for testing
                    return true;
                }
            }

            return false;
        }

        // Run anti-cheat analysis on all participants
        async function runAntiCheatAnalysis() {
            try {
                console.log('üîç Running anti-cheat analysis...');
                antiCheatState.analyzing = true;

                const resultsContainer = document.getElementById('anti-cheat-results');
                resultsContainer.style.display = 'block';
                resultsContainer.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p style="margin-top: 1rem;">Analyzing participant workouts...</p>
                    </div>
                `;

                // Get event details
                const startTag = currentEvent.tags.find(t => t[0] === 'start');
                const startDate = startTag ? new Date(startTag[1]).getTime() / 1000 : 0;

                const endTag = currentEvent.tags.find(t => t[0] === 'end');
                const endDate = endTag ? new Date(endTag[1]).getTime() / 1000 : Math.floor(Date.now() / 1000);

                const activityTag = currentEvent.tags.find(t => t[0] === 'activity_type');
                const activityType = activityTag ? activityTag[1] : 'running';

                // Fetch workouts for all participants
                const filter = {
                    kinds: [1301],
                    authors: participants,
                    since: Math.floor(startDate),
                    until: Math.floor(endDate)
                };

                const events = await pool.querySync(RELAYS, filter);
                const workouts = (events || []).filter(workout => {
                    const typeTag = workout.tags.find(t => t[0] === 'type');
                    return typeTag && typeTag[1] === activityType;
                });

                console.log(`üìä Analyzing ${workouts.length} workouts from ${participants.length} participants`);

                // Analyze each participant
                const analyses = [];

                for (const pubkey of participants) {
                    const participantWorkouts = workouts.filter(w => w.pubkey === pubkey);

                    if (participantWorkouts.length > 0) {
                        const analysis = analyzeParticipant(pubkey, participantWorkouts[0], workouts);
                        analyses.push(analysis);
                    } else {
                        // No workout submitted
                        analyses.push({
                            pubkey,
                            name: getParticipantName(pubkey),
                            riskScore: 0,
                            riskLevel: 'low',
                            flags: [{
                                type: 'no_workout',
                                severity: 'info',
                                message: 'No workout submitted for this event',
                                points: 0
                            }]
                        });
                    }
                }

                // Sort by risk score (highest first)
                analyses.sort((a, b) => b.riskScore - a.riskScore);

                // Display results
                displayAntiCheatResults(analyses);

                // Cache results
                cacheAntiCheatResults(eventId, analyses);

                antiCheatState.analyzing = false;

            } catch (error) {
                console.error('‚ùå Anti-cheat analysis failed:', error);
                alert('Analysis failed. Please try again.');
                antiCheatState.analyzing = false;
            }
        }

        // Analyze a single participant's workout
        function analyzeParticipant(pubkey, workout, allWorkouts) {
            const flags = [];
            let riskScore = 0;

            // Parse workout data
            const splits = parseSplitData(workout);
            const distanceTag = workout.tags.find(t => t[0] === 'distance');
            const distance = distanceTag ? parseFloat(distanceTag[1]) : 0;

            const durationTag = workout.tags.find(t => t[0] === 'duration');
            const duration = durationTag ? parseDuration(durationTag[1]) : 0;

            const avgPaceTag = workout.tags.find(t => t[0] === 'avg_pace');
            const avgPace = avgPaceTag ? parseDuration(avgPaceTag[1]) : 0;

            const dataPointsTag = workout.tags.find(t => t[0] === 'data_points');
            const dataPoints = dataPointsTag ? parseInt(dataPointsTag[1]) : 0;

            const workoutStartTag = workout.tags.find(t => t[0] === 'workout_start_time');
            const workoutStartTime = workoutStartTag ? parseInt(workoutStartTag[1]) : workout.created_at;

            const pausesTag = workout.tags.find(t => t[0] === 'recording_pauses');
            const pauses = pausesTag ? parseInt(pausesTag[1]) : 0;

            const publishingDelay = workout.created_at - workoutStartTime;

            // 1. Check for impossible pace jumps using split_pace tags
            const splitPaceTags = workout.tags.filter(t => t[0] === 'split_pace');
            if (splitPaceTags.length >= 2) {
                const paces = splitPaceTags.map(t => parseInt(t[2])).sort((a, b) => parseInt(t[1]) - parseInt(b[1]));

                for (let i = 1; i < paces.length; i++) {
                    const paceChange = Math.abs(paces[i] - paces[i-1]);

                    if (paceChange > 30) { // >30 sec/km change
                        flags.push({
                            type: 'impossible_pace_jump',
                            severity: 'high',
                            message: `Pace jumped ${Math.round(paceChange)}s/km between splits`,
                            points: 25
                        });
                        riskScore += 25;
                        break;
                    }
                }
            }

            // 2. Check for too perfect pacing
            if (splitPaceTags.length >= 3) {
                const paces = splitPaceTags.map(t => parseInt(t[2]));
                const avgSplitPace = paces.reduce((a, b) => a + b, 0) / paces.length;
                const variance = paces.reduce((sum, pace) => sum + Math.pow(pace - avgSplitPace, 2), 0) / paces.length;

                if (variance < 10) {
                    flags.push({
                        type: 'perfect_pacing',
                        severity: 'medium',
                        message: `Suspiciously consistent pacing (variance: ${variance.toFixed(1)}s)`,
                        points: 15
                    });
                    riskScore += 15;
                }
            }

            // 3. Check math consistency
            if (distance > 0 && duration > 0 && splits.length > 0) {
                const sumOfSplits = splits[splits.length - 1].elapsedSeconds;
                const discrepancy = Math.abs(sumOfSplits - duration) / duration;

                if (discrepancy > 0.05) {
                    flags.push({
                        type: 'math_inconsistency',
                        severity: 'high',
                        message: `Split times don't match total duration (${Math.round(discrepancy * 100)}% off)`,
                        points: 30
                    });
                    riskScore += 30;
                }
            }

            // 4. Check GPS data quality
            if (dataPoints > 0 && distance > 0 && duration > 0) {
                const expectedPoints = duration; // ~1 point per second
                const actualRatio = dataPoints / expectedPoints;

                if (actualRatio < 0.3) {
                    flags.push({
                        type: 'low_data_quality',
                        severity: 'high',
                        message: `Very few GPS points (${dataPoints} vs ~${Math.round(expectedPoints)} expected)`,
                        points: 20
                    });
                    riskScore += 20;
                }
            } else if (dataPoints === 0) {
                flags.push({
                    type: 'no_gps_data',
                    severity: 'medium',
                    message: 'No GPS data points recorded',
                    points: 10
                });
                riskScore += 10;
            }

            // 5. Check publishing delay
            const delayHours = publishingDelay / 3600;

            if (delayHours > 168) { // >1 week
                flags.push({
                    type: 'publishing_delay',
                    severity: 'medium',
                    message: `Published ${Math.round(delayHours / 24)} days after workout`,
                    points: 20
                });
                riskScore += 20;
            } else if (delayHours > 24) {
                flags.push({
                    type: 'publishing_delay',
                    severity: 'low',
                    message: `Published ${Math.round(delayHours)} hours after workout`,
                    points: 10
                });
                riskScore += 10;
            }

            // 6. Check account history (new account + elite performance)
            const participantWorkouts = allWorkouts.filter(w => w.pubkey === pubkey);

            if (participantWorkouts.length <= 2 && avgPace > 0 && avgPace < 300) { // <5:00/km
                flags.push({
                    type: 'new_account_elite',
                    severity: 'high',
                    message: `New account (${participantWorkouts.length} workouts) with elite pace (${formatReplayTime(avgPace)}/km)`,
                    points: 25
                });
                riskScore += 25;
            }

            // 7. Check for identical workouts
            const identicalCount = participantWorkouts.filter(w => {
                const wDistance = w.tags.find(t => t[0] === 'distance');
                const wDuration = w.tags.find(t => t[0] === 'duration');

                return wDistance && wDuration &&
                       Math.abs(parseFloat(wDistance[1]) - distance) < 0.01 &&
                       Math.abs(parseDuration(wDuration[1]) - duration) < 5;
            }).length;

            if (identicalCount >= 3) {
                flags.push({
                    type: 'identical_workouts',
                    severity: 'medium',
                    message: `${identicalCount} nearly identical workouts`,
                    points: 15
                });
                riskScore += 15;
            }

            // 8. Check for missing data fields
            const elevationGainTag = workout.tags.find(t => t[0] === 'elevation_gain');
            const elevationLossTag = workout.tags.find(t => t[0] === 'elevation_loss');

            if (!elevationGainTag && !elevationLossTag && distance > 3) {
                flags.push({
                    type: 'missing_elevation',
                    severity: 'low',
                    message: 'No elevation data for multi-kilometer run',
                    points: 5
                });
                riskScore += 5;
            }

            if (splits.length === 0 && distance > 1) {
                flags.push({
                    type: 'missing_splits',
                    severity: 'low',
                    message: 'No split data recorded',
                    points: 5
                });
                riskScore += 5;
            }

            // Determine risk level
            let riskLevel = 'low';
            if (riskScore > 60) riskLevel = 'high';
            else if (riskScore > 30) riskLevel = 'medium';

            return {
                pubkey,
                name: getParticipantName(pubkey),
                riskScore,
                riskLevel,
                flags
            };
        }

        // Cache anti-cheat results to localStorage
        function cacheAntiCheatResults(eventId, analyses) {
            const cacheKey = `anti_cheat_${eventId}`;
            const cacheData = {
                timestamp: Date.now(),
                analyses: analyses
            };
            localStorage.setItem(cacheKey, JSON.stringify(cacheData));
            console.log('üíæ Anti-cheat results cached');
        }

        // Load cached anti-cheat results
        function loadCachedAntiCheatResults(eventId) {
            const cacheKey = `anti_cheat_${eventId}`;
            const cached = localStorage.getItem(cacheKey);

            if (!cached) return null;

            const cacheData = JSON.parse(cached);

            // Cache expires after 7 days
            const cacheAge = Date.now() - cacheData.timestamp;
            if (cacheAge > 7 * 24 * 60 * 60 * 1000) {
                localStorage.removeItem(cacheKey);
                return null;
            }

            console.log('‚úÖ Loaded cached anti-cheat results');
            return cacheData.analyses;
        }

        // Display anti-cheat analysis results
        function displayAntiCheatResults(analyses) {
            const resultsContainer = document.getElementById('anti-cheat-results');

            const riskEmoji = {
                'low': '‚úÖ',
                'medium': '‚ö†Ô∏è',
                'high': 'üö®'
            };

            const html = `
                <div style="padding: 1rem;">
                    <div style="margin-bottom: 1.5rem; text-align: center;">
                        <p style="color: var(--light-gray); font-size: 0.95rem;">
                            Analysis completed for ${analyses.length} participants
                        </p>
                    </div>

                    <div class="anti-cheat-list">
                        ${analyses.map(analysis => {
                            const emoji = riskEmoji[analysis.riskLevel];

                            return `
                                <div class="anti-cheat-item risk-${analysis.riskLevel}">
                                    <div class="anti-cheat-header">
                                        <div class="anti-cheat-name">
                                            ${emoji} ${analysis.name}
                                        </div>
                                        <div class="anti-cheat-score">
                                            <div class="anti-cheat-score-value">${analysis.riskScore}</div>
                                            <div class="anti-cheat-score-label">${analysis.riskLevel} risk</div>
                                        </div>
                                    </div>

                                    ${analysis.flags.length > 0 ? `
                                        <div class="anti-cheat-flags">
                                            <div class="anti-cheat-flags-header">Flags:</div>
                                            ${analysis.flags.map(flag => `
                                                <div class="anti-cheat-flag">${flag.message}</div>
                                            `).join('')}
                                        </div>
                                    ` : `
                                        <div class="anti-cheat-no-flags">No suspicious patterns detected</div>
                                    `}
                                </div>
                            `;
                        }).join('')}
                    </div>

                    <div class="anti-cheat-disclaimer">
                        <p>
                            <strong>Note:</strong> This analysis uses statistical patterns to flag suspicious workouts.
                            High risk scores do not guarantee cheating - review flags carefully before taking action.
                            Factors like training improvements, GPS signal loss, or device issues can cause false positives.
                        </p>
                    </div>
                </div>
            `;

            resultsContainer.innerHTML = html;
        }

        // Render leaderboard item
        function renderLeaderboardItem(ranking, rank, competitionType) {
            const shortPubkey = ranking.pubkey.substring(0, 8) + '...' + ranking.pubkey.substring(ranking.pubkey.length - 8);
            const rankClass = rank <= 3 ? `rank-${rank}` : '';

            return `
                <div class="leaderboard-item">
                    <div class="rank ${rankClass}">#${rank}</div>
                    <div class="participant-info">
                        <div class="participant-name">Athlete</div>
                        <div class="participant-pubkey">${shortPubkey}</div>
                    </div>
                    <div class="score">
                        <div class="score-value">${ranking.score} ${ranking.unit}</div>
                        <div class="score-label">${ranking.workoutCount} workout${ranking.workoutCount !== 1 ? 's' : ''}</div>
                    </div>
                </div>
            `;
        }

        // Update join button visibility
        function updateJoinButton() {
            const joinBtn = document.getElementById('join-btn');
            const pendingBtn = document.getElementById('pending-btn');

            if (!currentUser) {
                joinBtn.style.display = 'none';
                pendingBtn.style.display = 'none';
                return;
            }

            const isParticipant = participants.includes(currentUser.pubkey);

            if (isParticipant) {
                joinBtn.style.display = 'none';
                pendingBtn.style.display = 'none';
            } else {
                joinBtn.style.display = 'block';
                pendingBtn.style.display = 'none';
            }
        }

        // Join event
        async function joinEvent() {
            if (!currentUser) {
                alert('Please log in to join this event');
                return;
            }

            try {
                const joinBtn = document.getElementById('join-btn');
                joinBtn.disabled = true;
                joinBtn.textContent = 'Submitting...';

                // Check if approval is required
                const requireApprovalTag = currentEvent.tags.find(t => t[0] === 'require_approval');
                const requireApproval = requireApprovalTag && requireApprovalTag[1] === 'true';

                if (requireApproval) {
                    // Create join request (kind 1105)
                    const joinRequestEvent = {
                        kind: 1105,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ['e', eventId, '', 'request'],
                            ['p', captainPubkey],
                            ['status', 'pending']
                        ],
                        content: `Join request for event: ${currentEvent.tags.find(t => t[0] === 'name')?.[1] || 'Unnamed Event'}`
                    };

                    const signedRequest = await window.nostr.signEvent(joinRequestEvent);

                    await Promise.any(
                        RELAYS.map(relay => pool.publish(relay, signedRequest))
                    );

                    console.log('‚úÖ Join request submitted');

                    // Update UI
                    joinBtn.style.display = 'none';
                    document.getElementById('pending-btn').style.display = 'block';

                    alert('Join request submitted! Waiting for captain approval.');

                } else {
                    // Direct join (update participant list)
                    alert('Direct join coming soon! This will update the participant list without approval.');
                    joinBtn.disabled = false;
                    joinBtn.textContent = 'Join Event';
                }

            } catch (error) {
                console.error('‚ùå Failed to join event:', error);
                alert('Failed to join event: ' + error.message);

                const joinBtn = document.getElementById('join-btn');
                joinBtn.disabled = false;
                joinBtn.textContent = 'Join Event';
            }
        }

        // Refresh leaderboard
        async function refreshLeaderboard() {
            await loadLeaderboard();
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initializeNostr();
            loadEvent();
        });
    </script>
</body>
</html>
